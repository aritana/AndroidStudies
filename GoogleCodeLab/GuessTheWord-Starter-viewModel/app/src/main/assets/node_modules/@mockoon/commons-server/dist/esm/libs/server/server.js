import { BINARY_BODY, CORSHeaders, GetContentType, GetRouteResponseContentType, IsValidURL, MimeTypesWithTemplating, ServerErrorCodes } from '@mockoon/commons';
import cookieParser from 'cookie-parser';
import { EventEmitter } from 'events';
import express from 'express';
import { createReadStream, readFile, readFileSync, statSync } from 'fs';
import { createServer as httpCreateServer } from 'http';
import { createProxyMiddleware } from 'http-proxy-middleware';
import { createServer as httpsCreateServer } from 'https';
import killable from 'killable';
import { lookup as mimeTypeLookup } from 'mime-types';
import { basename } from 'path';
import { parse as qsParse } from 'qs';
import { xml2js } from 'xml-js';
import { DefaultTLSOptions } from '../../constants/ssl.constants';
import { Texts } from '../../i18n/en';
import { ResponseRulesInterpreter } from '../response-rules-interpreter';
import { TemplateParser } from '../template-parser';
import { CreateTransaction, resolvePathFromEnvironment } from '../utils';
/**
 * Create a server instance from an Environment object.
 *
 * Extends EventEmitter.
 */
export class MockoonServer extends EventEmitter {
    constructor(environment, options = {}) {
        super();
        this.environment = environment;
        this.options = options;
        this.tlsOptions = {};
        /**
         * ### Middleware ###
         * Emit the SERVER_ENTERING_REQUEST event
         *
         * @param request
         * @param response
         * @param next
         */
        this.emitEvent = (request, response, next) => {
            this.emit('entering-request');
            next();
        };
        /**
         * ### Middleware ###
         * Add global latency to the mock server
         *
         * @param request
         * @param response
         * @param next
         */
        this.delayResponse = (request, response, next) => {
            this.refreshEnvironment();
            setTimeout(next, this.environment.latency);
        };
        /**
         * ### Middleware ###
         * Parse entering request body
         *
         * @param request
         * @param response
         * @param next
         */
        this.parseBody = (request, response, next) => {
            // Parse body as a raw string and JSON/form if applicable
            const requestContentType = request.header('Content-Type');
            const rawBody = [];
            request.on('data', (chunk) => {
                rawBody.push(Buffer.from(chunk, 'binary'));
            });
            request.on('end', () => {
                request.rawBody = Buffer.concat(rawBody);
                request.stringBody = request.rawBody.toString('utf8');
                try {
                    if (requestContentType) {
                        if (requestContentType.includes('application/json')) {
                            request.body = JSON.parse(request.stringBody);
                        }
                        else if (requestContentType.includes('application/x-www-form-urlencoded')) {
                            request.body = qsParse(request.stringBody, {
                                depth: 10
                            });
                        }
                        else if (requestContentType.includes('application/xml') ||
                            requestContentType.includes('text/xml')) {
                            request.body = xml2js(request.stringBody, {
                                compact: true
                            });
                        }
                    }
                }
                catch (error) {
                    this.emit('error', ServerErrorCodes.REQUEST_BODY_PARSE, error);
                }
                next();
            });
        };
        /**
         * ### Middleware ###
         * Emit an event when response emit the 'close' event
         *
         * @param request
         * @param response
         * @param next
         */
        this.logRequest = (request, response, next) => {
            response.on('close', () => {
                this.emit('transaction-complete', CreateTransaction(request, response));
            });
            next();
        };
        /**
         * ### Middleware ###
         * Add environment headers & proxy headers to the response
         *
         * @param request
         * @param response
         * @param next
         */
        this.setResponseHeaders = (request, response, next) => {
            this.setHeaders(this.environment.headers, response, request);
            next();
        };
        /**
         * ### Middleware ###
         * Catch all error handler
         * http://expressjs.com/en/guide/error-handling.html#catching-errors
         *
         * @param server - server on which to log the response
         */
        this.errorHandler = (error, request, response, next) => {
            this.sendError(response, error, 500);
        };
    }
    /**
     * Start a server
     */
    start() {
        const server = express();
        server.disable('x-powered-by');
        server.disable('etag');
        // create https or http server instance
        if (this.environment.tlsOptions.enabled) {
            try {
                this.tlsOptions = this.buildTLSOptions(this.environment);
                this.serverInstance = httpsCreateServer(this.tlsOptions, server);
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    this.emit('error', ServerErrorCodes.CERT_FILE_NOT_FOUND, error);
                }
                else {
                    this.emit('error', ServerErrorCodes.UNKNOWN_SERVER_ERROR, error);
                }
            }
        }
        else {
            this.serverInstance = httpCreateServer(server);
        }
        // make serverInstance killable
        this.serverInstance = killable(this.serverInstance);
        // set timeout long enough to allow long latencies
        this.serverInstance.setTimeout(3600000);
        // handle server errors
        this.serverInstance.on('error', (error) => {
            let errorCode;
            switch (error.code) {
                case 'EADDRINUSE':
                    errorCode = ServerErrorCodes.PORT_ALREADY_USED;
                    break;
                case 'EACCES':
                    errorCode = ServerErrorCodes.PORT_INVALID;
                    break;
                case 'EADDRNOTAVAIL':
                    errorCode = ServerErrorCodes.HOSTNAME_UNAVAILABLE;
                    break;
                case 'ENOTFOUND':
                    errorCode = ServerErrorCodes.HOSTNAME_UNKNOWN;
                    break;
                default:
                    errorCode = ServerErrorCodes.UNKNOWN_SERVER_ERROR;
            }
            this.emit('error', errorCode, error);
        });
        this.serverInstance.listen(this.environment.port, this.environment.hostname, () => {
            this.emit('started');
        });
        server.use(this.emitEvent);
        server.use(this.delayResponse);
        server.use(this.deduplicateSlashes);
        server.use(cookieParser());
        server.use(this.parseBody);
        server.use(this.logRequest);
        server.use(this.setResponseHeaders);
        this.setRoutes(server);
        this.setCors(server);
        this.enableProxy(server);
        server.use(this.errorHandler);
    }
    /**
     * Kill the server
     */
    stop() {
        if (this.serverInstance) {
            this.serverInstance.kill(() => {
                this.emit('stopped');
            });
        }
    }
    /**
     * ### Middleware ###
     * Remove duplicate slashes in entering call paths
     *
     * @param request
     * @param response
     * @param next
     */
    deduplicateSlashes(request, response, next) {
        request.url = request.url.replace(/\/{2,}/g, '/');
        next();
    }
    /**
     * Generate an environment routes and attach to running server
     *
     * @param server - server on which attach routes
     */
    setRoutes(server) {
        this.environment.routes.forEach((declaredRoute) => {
            // only launch non duplicated routes, or ignore if none.
            if (declaredRoute.enabled) {
                try {
                    let routePath = `/${this.environment.endpointPrefix}/${declaredRoute.endpoint.replace(/ /g, '%20')}`;
                    routePath = routePath.replace(/\/{2,}/g, '/');
                    this.createRESTRoute(server, declaredRoute, routePath);
                }
                catch (error) {
                    let errorCode = ServerErrorCodes.ROUTE_CREATION_ERROR;
                    // if invalid regex defined
                    if (error.message.indexOf('Invalid regular expression') > -1) {
                        errorCode = ServerErrorCodes.ROUTE_CREATION_ERROR_REGEX;
                    }
                    this.emit('error', errorCode, error);
                }
            }
        });
    }
    /**
     * Create a regular REST route (GET, POST, etc.)
     *
     * @param server
     * @param route
     * @param routePath
     * @param requestNumber
     */
    createRESTRoute(server, route, routePath) {
        let requestNumber = 1;
        server[route.method](routePath, (request, response) => {
            // refresh environment data to get route changes that do not require a restart (headers, body, etc)
            this.refreshEnvironment();
            const currentRoute = this.getRefreshedRoute(route);
            if (!currentRoute) {
                this.sendError(response, Texts.EN.MESSAGES.ROUTE_NO_LONGER_EXISTS, 404);
                return;
            }
            const enabledRouteResponse = new ResponseRulesInterpreter(currentRoute.responses, request, currentRoute.randomResponse, currentRoute.sequentialResponse).chooseResponse(requestNumber);
            requestNumber += 1;
            // save route and response UUIDs for logs (only in desktop app)
            if (route.uuid && enabledRouteResponse.uuid) {
                response.routeUUID = route.uuid;
                response.routeResponseUUID = enabledRouteResponse.uuid;
            }
            // add route latency if any
            setTimeout(() => {
                const contentType = GetRouteResponseContentType(this.environment, enabledRouteResponse);
                const routeContentType = GetContentType(enabledRouteResponse.headers);
                // set http code
                response.status(enabledRouteResponse.statusCode);
                this.setHeaders(enabledRouteResponse.headers, response, request);
                // send the file
                if (enabledRouteResponse.filePath) {
                    this.sendFile(enabledRouteResponse, routeContentType, request, response);
                }
                else {
                    if (contentType.includes('application/json')) {
                        response.set('Content-Type', 'application/json');
                    }
                    this.serveBody(enabledRouteResponse, request, response);
                }
            }, enabledRouteResponse.latency);
        });
    }
    /**
     * Parse the body templating and send it as the response body
     *
     * @param routeResponse
     * @param request
     * @param response
     */
    serveBody(routeResponse, request, response) {
        try {
            let body = routeResponse.body;
            if (!routeResponse.disableTemplating) {
                body = TemplateParser(body || '', request, this.environment);
            }
            response.body = body;
            response.send(body);
        }
        catch (error) {
            this.emit('error', ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${Texts.EN.MESSAGES.ROUTE_SERVING_ERROR}${error.message}`);
        }
    }
    /**
     * Send a file as response body.
     * Revert to sendBody if file is not found.
     *
     * @param routeResponse
     * @param routeContentType
     * @param request
     * @param response
     */
    sendFile(routeResponse, routeContentType, request, response) {
        const fileServingError = (error) => {
            this.emit('error', ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, error);
            this.sendError(response, `${Texts.EN.MESSAGES.ROUTE_FILE_SERVING_ERROR}${error.message}`);
        };
        const errorThrowOrFallback = (error) => {
            if (routeResponse.fallbackTo404) {
                response.status(404);
                this.serveBody(routeResponse, request, response);
            }
            else {
                fileServingError(error);
            }
        };
        try {
            let filePath = TemplateParser(routeResponse.filePath.replace(/\\/g, '/'), request, this.environment);
            filePath = resolvePathFromEnvironment(filePath, this.options.environmentDirectory);
            const fileMimeType = mimeTypeLookup(filePath) || '';
            // set content-type to route response's one or the detected mime type if none
            if (!routeContentType) {
                response.set('Content-Type', fileMimeType);
            }
            if (!routeResponse.sendFileAsBody) {
                response.set('Content-Disposition', `attachment; filename="${basename(filePath)}"`);
            }
            // parse templating for a limited list of mime types
            if (MimeTypesWithTemplating.indexOf(fileMimeType) > -1 &&
                !routeResponse.disableTemplating) {
                readFile(filePath, (readError, data) => {
                    if (readError) {
                        errorThrowOrFallback(readError);
                        return;
                    }
                    try {
                        const fileContent = TemplateParser(data.toString(), request, this.environment);
                        response.body = fileContent;
                        response.send(fileContent);
                    }
                    catch (error) {
                        fileServingError(error);
                    }
                });
            }
            else {
                try {
                    response.body = BINARY_BODY;
                    const { size } = statSync(filePath);
                    this.setHeaders([
                        {
                            key: 'Content-Length',
                            value: size.toString()
                        }
                    ], response, request);
                    // use read stream for better performance
                    createReadStream(filePath).pipe(response);
                }
                catch (error) {
                    errorThrowOrFallback(error);
                }
            }
        }
        catch (error) {
            this.emit('error', ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${Texts.EN.MESSAGES.ROUTE_SERVING_ERROR}${error.message}`);
        }
    }
    /**
     * Always answer with status 200 to CORS pre flight OPTIONS requests if option activated.
     * /!\ Must be called after the routes creation otherwise it will intercept all user defined OPTIONS routes.
     *
     * @param server - express instance
     */
    setCors(server) {
        if (this.environment.cors) {
            server.options('/*', (req, res) => {
                this.refreshEnvironment();
                // override default CORS headers with environment's headers
                this.setHeaders([...CORSHeaders, ...this.environment.headers], res, req);
                res.status(200).end();
            });
        }
    }
    /**
     * Add catch-all proxy if enabled.
     * Restream the body to the proxied API because it already has been
     * intercepted by the body parser.
     *
     * @param server - server on which to launch the proxy
     */
    enableProxy(server) {
        if (this.environment.proxyMode &&
            this.environment.proxyHost &&
            IsValidURL(this.environment.proxyHost)) {
            this.emit('creating-proxy');
            server.use('*', createProxyMiddleware({
                cookieDomainRewrite: { '*': '' },
                target: this.environment.proxyHost,
                secure: false,
                changeOrigin: true,
                logProvider: this.options.logProvider,
                ssl: Object.assign(Object.assign({}, this.tlsOptions), { agent: false }),
                onProxyReq: (proxyReq, request, response) => {
                    this.refreshEnvironment();
                    request.proxied = true;
                    this.setHeaders(this.environment.proxyReqHeaders, proxyReq, request);
                    if (this.environment.proxyRemovePrefix === true &&
                        this.environment.endpointPrefix.length > 0) {
                        const regExp = new RegExp(`^/${this.environment.endpointPrefix}`);
                        proxyReq.path = proxyReq.path.replace(regExp, '');
                    }
                    // re-stream the body (intercepted by body parser method)
                    if (request.rawBody) {
                        proxyReq.write(request.rawBody);
                    }
                },
                onProxyRes: (proxyRes, request, response) => {
                    this.refreshEnvironment();
                    const buffers = [];
                    proxyRes.on('data', (chunk) => {
                        buffers.push(chunk);
                    });
                    proxyRes.on('end', () => {
                        response.body = Buffer.concat(buffers);
                    });
                    this.setHeaders(this.environment.proxyResHeaders, proxyRes, request);
                },
                onError: (error, request, response) => {
                    this.emit('error', ServerErrorCodes.PROXY_ERROR, error);
                    this.sendError(response, `${Texts.EN.MESSAGES.PROXY_ERROR}${this.environment.proxyHost}${request.url}: ${error}`, 504);
                }
            }));
        }
    }
    /**
     * Set the provided headers on the target. Use different headers accessors
     * depending on the type of target:
     * express.Response/http.OutgoingMessage/http.IncomingMessage
     * Use the source in the template parsing of each header value.
     *
     * @param headers
     * @param target
     * @param request
     */
    setHeaders(headers, target, request) {
        headers.forEach((header) => {
            try {
                const isSetCookie = header.key.toLowerCase() === 'set-cookie';
                let parsedHeaderValue = this.parseHeader(header, request);
                if (parsedHeaderValue === null) {
                    return;
                }
                if (target.set) {
                    // for express.Response
                    if (isSetCookie) {
                        target.append(header.key, parsedHeaderValue);
                    }
                    else {
                        target.set(header.key, parsedHeaderValue);
                    }
                }
                else if (target.setHeader) {
                    // for proxy http.OutgoingMessage | ClientRequest
                    target.setHeader(header.key, parsedHeaderValue);
                }
                else {
                    // for http.IncomingMessage
                    if (isSetCookie) {
                        // Remove the secure flag
                        parsedHeaderValue = parsedHeaderValue.replace(/; secure/gi, '');
                        target.headers[header.key] = this.appendHeaderValue(target.headers[header.key], parsedHeaderValue);
                    }
                    else {
                        target.headers[header.key] = parsedHeaderValue;
                    }
                }
            }
            catch (error) { }
        });
    }
    /**
     * If header already has a value, concatenate the values into an array
     *
     * @param currentValue
     * @param newValue
     * @returns
     */
    appendHeaderValue(currentValue, newValue) {
        let headerValue = newValue;
        if (currentValue) {
            headerValue = Array.isArray(currentValue)
                ? currentValue.concat(headerValue)
                : [currentValue, headerValue];
        }
        return headerValue;
    }
    /**
     * Verify a header validity and parse its content, if templating is used
     *
     * @param header
     * @param request
     * @returns
     */
    parseHeader(header, request) {
        let parsedHeaderValue = null;
        if (header.key && header.value) {
            try {
                parsedHeaderValue = TemplateParser(header.value, request, this.environment);
            }
            catch (error) {
                const errorMessage = Texts.EN.MESSAGES.HEADER_PARSING_ERROR;
                parsedHeaderValue = errorMessage;
            }
        }
        return parsedHeaderValue;
    }
    /**
     * Send an error with text/plain content type, the provided message and status code.
     * Status is optional. No status will default to the one defined by the user, allowing for maximum customization.
     *
     * @param response
     * @param errorMessage
     * @param status
     */
    sendError(response, errorMessage, status) {
        response.set('Content-Type', 'text/plain');
        response.body = errorMessage;
        if (status !== undefined) {
            response.status(status);
        }
        response.send(errorMessage);
    }
    /**
     * Request an updated environment to allow
     * modification of some parameters without a restart (latency, headers, etc)
     */
    refreshEnvironment() {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            const updatedEnvironment = this.options.refreshEnvironmentFunction(this.environment.uuid);
            if (updatedEnvironment) {
                this.environment = updatedEnvironment;
            }
        }
    }
    /**
     * Request an updated route to allow
     * modification of some parameters without a restart (latency, headers, etc)
     * This only makes sense if the refreshEnvironmentFunction has been provided.
     *
     * @param routeUUID
     */
    getRefreshedRoute(currentRoute) {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            return this.environment.routes.find((route) => route.uuid === currentRoute.uuid);
        }
        return currentRoute;
    }
    /**
     * Build the secure context options
     * - if custom cert are provided load them
     * - if not, use default TLS cert (self-signed)
     *
     * @returns
     */
    buildTLSOptions(environment) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        let tlsOptions = {};
        if (((_a = environment.tlsOptions) === null || _a === void 0 ? void 0 : _a.pfxPath) ||
            (((_b = environment.tlsOptions) === null || _b === void 0 ? void 0 : _b.certPath) && ((_c = environment.tlsOptions) === null || _c === void 0 ? void 0 : _c.keyPath))) {
            if (((_d = environment.tlsOptions) === null || _d === void 0 ? void 0 : _d.type) === 'PFX' &&
                ((_e = environment.tlsOptions) === null || _e === void 0 ? void 0 : _e.pfxPath)) {
                tlsOptions.pfx = readFileSync(resolvePathFromEnvironment((_f = environment.tlsOptions) === null || _f === void 0 ? void 0 : _f.pfxPath, this.options.environmentDirectory));
            }
            else if (((_g = environment.tlsOptions) === null || _g === void 0 ? void 0 : _g.type) === 'CERT' &&
                ((_h = environment.tlsOptions) === null || _h === void 0 ? void 0 : _h.certPath) &&
                ((_j = environment.tlsOptions) === null || _j === void 0 ? void 0 : _j.keyPath)) {
                tlsOptions.cert = readFileSync(resolvePathFromEnvironment((_k = environment.tlsOptions) === null || _k === void 0 ? void 0 : _k.certPath, this.options.environmentDirectory));
                tlsOptions.key = readFileSync(resolvePathFromEnvironment((_l = environment.tlsOptions) === null || _l === void 0 ? void 0 : _l.keyPath, this.options.environmentDirectory));
            }
            if ((_m = environment.tlsOptions) === null || _m === void 0 ? void 0 : _m.caPath) {
                tlsOptions.ca = readFileSync(resolvePathFromEnvironment((_o = environment.tlsOptions) === null || _o === void 0 ? void 0 : _o.caPath, this.options.environmentDirectory));
            }
            if ((_p = environment.tlsOptions) === null || _p === void 0 ? void 0 : _p.passphrase) {
                tlsOptions.passphrase = (_q = environment.tlsOptions) === null || _q === void 0 ? void 0 : _q.passphrase;
            }
        }
        else {
            tlsOptions = Object.assign({}, DefaultTLSOptions);
        }
        return tlsOptions;
    }
}
//# sourceMappingURL=server.js.map