"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePathFromEnvironment = exports.numberFromSafeString = exports.fromSafeString = exports.ToBase64 = exports.CreateTransaction = exports.DecompressBody = exports.RandomInt = exports.IsEmpty = void 0;
const handlebars_1 = require("handlebars");
const path_1 = require("path");
const url_1 = require("url");
const zlib_1 = require("zlib");
/**
 * Transform http headers objects to Mockoon's Header key value object
 *
 * @param object
 */
const TransformHeaders = (headers) => Object.keys(headers).reduce((newHeaders, key) => {
    const headerValue = headers[key];
    let value = '';
    if (headerValue !== undefined) {
        if (Array.isArray(headerValue)) {
            value = headerValue.join(',');
        }
        else {
            value = headerValue.toString();
        }
    }
    newHeaders.push({ key, value });
    return newHeaders;
}, []);
/**
 * Sort by ascending order
 *
 * @param a
 * @param b
 */
const AscSort = (a, b) => {
    if (a.key < b.key) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
const IsEmpty = (obj) => [Object, Array].includes((obj || {}).constructor) &&
    !Object.entries(obj || {}).length;
exports.IsEmpty = IsEmpty;
/**
 * Return a random integer
 *
 * @param a
 * @param b
 */
const RandomInt = (a = 1, b = 0) => {
    const lower = Math.ceil(Math.min(a, b));
    const upper = Math.floor(Math.max(a, b));
    return Math.floor(lower + Math.random() * (upper - lower + 1));
};
exports.RandomInt = RandomInt;
/**
 * Decompress body based on content-encoding
 *
 * @param response
 */
const DecompressBody = (response) => {
    if (!response.body) {
        return response.body;
    }
    const contentEncoding = response.getHeader('content-encoding');
    let body = response.body;
    switch (contentEncoding) {
        case 'gzip':
            body = (0, zlib_1.unzipSync)(body);
            break;
        case 'br':
            body = (0, zlib_1.brotliDecompressSync)(body);
            break;
        case 'deflate':
            body = (0, zlib_1.inflateSync)(body);
            break;
        default:
            break;
    }
    return body.toString('utf-8');
};
exports.DecompressBody = DecompressBody;
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
function CreateTransaction(request, response) {
    const requestUrl = new url_1.URL(request.originalUrl, 'http://localhost/');
    return {
        request: {
            method: request.method.toLowerCase(),
            urlPath: requestUrl.pathname,
            route: request.route ? request.route.path : null,
            params: request.params
                ? Object.keys(request.params).map((paramName) => ({
                    name: paramName,
                    value: request.params[paramName]
                }))
                : [],
            query: requestUrl ? decodeURI(requestUrl.search.slice(1)) : null,
            queryParams: request.query,
            body: request.stringBody,
            headers: TransformHeaders(request.headers).sort(AscSort)
        },
        response: {
            statusCode: response.statusCode,
            headers: TransformHeaders(response.getHeaders()).sort(AscSort),
            body: (0, exports.DecompressBody)(response)
        },
        routeResponseUUID: response.routeResponseUUID,
        routeUUID: response.routeUUID,
        proxied: request.proxied || false
    };
}
exports.CreateTransaction = CreateTransaction;
/**
 * Convert a string to base64
 *
 * @param text
 */
const ToBase64 = (text) => {
    if (typeof btoa === 'function') {
        return btoa(text);
    }
    if (typeof Buffer === 'function') {
        return Buffer.from(text).toString('base64');
    }
    return text;
};
exports.ToBase64 = ToBase64;
/**
 * Convert a SafeString to a string if needed.
 *
 * @param text
 * @returns
 */
const fromSafeString = (text) => text instanceof handlebars_1.SafeString ? text.toString() : text;
exports.fromSafeString = fromSafeString;
/**
 * Parse a number from a SafeString if needed.
 *
 * @param text
 * @returns
 */
const numberFromSafeString = (text) => {
    const parsedText = text instanceof handlebars_1.SafeString ? text.toString() : text;
    return parseInt(parsedText, 10);
};
exports.numberFromSafeString = numberFromSafeString;
/**
 * Resolve a file path relatively to the current environment folder if provided
 */
const resolvePathFromEnvironment = (filePath, environmentDirectory) => {
    if (environmentDirectory && !(0, path_1.isAbsolute)(filePath)) {
        return (0, path_1.resolve)(environmentDirectory, filePath);
    }
    return filePath;
};
exports.resolvePathFromEnvironment = resolvePathFromEnvironment;
//# sourceMappingURL=utils.js.map